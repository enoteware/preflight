#!/usr/bin/env tsx
/**
 * Preflight check - validates development environment
 */

import { config } from 'dotenv';
import { resolve } from 'path';

// Load environment variables
config({ path: resolve(process.cwd(), '.env.local') });
config({ path: resolve(process.cwd(), '..', '.env.local') });

import { checkNode, checkPackageManager } from './preflight-validators/cli';
import { validateEnvVars } from './preflight-validators/env';
import { checkGitHubAPI, checkPublicAPI } from './preflight-validators/services';
import { CheckResult, CheckSummary } from './preflight-validators/types';

async function runChecks(quickMode = false, skipGit = false): Promise<CheckSummary[]> {
  const summaries: CheckSummary[] = [];
  
  // CLI Tools
  const cliResults: CheckResult[] = [
    checkNode(),
    checkPackageManager('npm'),
  ];
  summaries.push({ category: 'CLI Tools', results: cliResults });
  
  // Configuration: Environment Variables
  // These checks only verify if env vars are SET, not if services are reachable
  const envResults = validateEnvVars();
  summaries.push({ category: 'Environment Variables', results: envResults });
  
  // Service Connections: Connectivity checks
  // These make REAL API calls to verify your keys are working (not just set).
  // Each check will:
  // - Make an authenticated API request using the env var
  // - Verify response is 200 OK (key is valid)
  // - Return error if 401 (invalid/expired key) or other failures
  // This ensures your API keys are actually WORKING, not just configured.
  const serviceResults: CheckResult[] = [];
  
  // Always run public API check (fast, no auth required - verifies internet connectivity)
  const publicApiResult = await checkPublicAPI();
  serviceResults.push(publicApiResult);
  
  // Check authenticated APIs (if not in quick mode)
  // These verify your API keys are valid by making real authenticated requests
  if (!quickMode) {
    const githubApiResult = await checkGitHubAPI();
    serviceResults.push(githubApiResult);
  }
  
  summaries.push({ category: 'Service Connections', results: serviceResults });
  
  return summaries;
}

async function main() {
  const args = process.argv.slice(2);
  const jsonOutput = args.includes('--json') || args.includes('--status');
  const quick = args.includes('--quick');
  const skipGit = args.includes('--skip-git');
  
  const summaries = await runChecks(quick, skipGit);
  
  // Add timestamps
  summaries.forEach(summary => {
    summary.results.forEach(result => {
      result.timestamp = Date.now();
    });
  });
  
  if (jsonOutput) {
    console.log(JSON.stringify({ summaries }, null, 2));
    process.exit(0);
  }
  
  console.log('\nüîç Preflight Check Results\n');
  
  let hasErrors = false;
  let hasWarnings = false;
  
  for (const summary of summaries) {
    console.log(`\nüì¶ ${summary.category}`);
    for (const result of summary.results) {
      const icon = result.status === 'ok' ? '‚úÖ' : result.status === 'warning' ? '‚ö†Ô∏è' : '‚ùå';
      console.log(`   ${icon} ${result.message}`);
      if (result.details) {
        console.log(`      ${result.details}`);
      }
      if (result.helpUrl) {
        console.log(`      Help: ${result.helpUrl}`);
      }
      
      if (result.status === 'error') hasErrors = true;
      if (result.status === 'warning') hasWarnings = true;
    }
  }
  
  console.log('\n' + '='.repeat(50) + '\n');
  
  if (hasErrors) {
    console.log('‚ùå Some checks failed!');
    process.exit(1);
  } else if (hasWarnings) {
    console.log('‚ö†Ô∏è  All checks passed with warnings');
    process.exit(0);
  } else {
    console.log('‚úÖ All checks passed!');
    process.exit(0);
  }
}

main().catch(console.error);
